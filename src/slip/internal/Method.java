package slip.internal; 

import java.util.ArrayList;
import java.util.List;

public class Method extends Stmt 
// Method declaration : name(x,...,x) ld {stmts} lf xr
{
   public String  m ; // Method identifier 
			
   public boolean isStatic ; // true --> static ; false --> non static
			
   public int level ; // level >= 0 (if non static) : name ::= m/level
   public int arity ; // Number of formal parameters (x_1, ..., x_arity) (method arity)
   public Stmt   l   ; // label of the first instruction (ld)
   int    nlv ; // Number of local variables (in source code)
   int    nav ; // Number of auxiliary variables (generated by the translation process)
   int    r   ; // result variable (xr) 0 <= r <= nlv + nav
   // final label (lf) : this
   String[]  var ; // the names of all local variables var[i] = i+1 th variable name
   LMAInstruction returnInstr;
   
   public Method(String m, String[] var, boolean isStatic,
                 int level, int arity, 
                 int nlv, int r)
   {
     this.m = m ;
     this.var = var ;
     this.isStatic = isStatic ;
     this.level = level ;
     this.arity = arity ;
     this.nlv = nlv ;
     this.r = r ;  
   }

   public void setPar(Stmt l, int nav)
   {  this.l = l ; this.nav = nav ; }

   

   public String toString()
   {
      magic++ ;
      vt = var ;

      String res = toStringBis() + ELN + "{ " + (l.label) + ELN ;

      if (l != this) res += l ; // print all statements

      res += ELN + "} " + this.label + " " + varName(r) ;

      res += ELN + "end of method " + m + "." + ELN + ELN ;

      return res ;
   }

   public String toComment()
   {
      return "end of method " + m + " : " + this.label + " " + varName(r) ;
   }

   public String toStringBis()
   {
      

      String res = "method " + m ;

      if (level >= 0) res += "/" + level;
             res += "(";

      if (arity >= 1)
      {
         res += var[0];
         int i = 1;
         while (i!=arity)
         {
            res+= ", " + var[i] ; i++ ;
         }
      }

      res += ")" ;

      return res ;

   }


	public List<LMAInstruction> translate() 
	{
		ArrayList<LMAInstruction> res = new ArrayList<LMAInstruction>();
		ArrayList<CondStmt> CondListStmt = new ArrayList<CondStmt>();
		
		// On considère que la méthode est générée
		generated = true;
		// On définit le level courant pour les appels super
		currentLevel = level;
		
		res.add(new LMAInstruction("method " + m + ((!isStatic)?"/" + level:"") + "()"));
		// Assez de place pour créer les variables de la méthode?
		res.add(new LMAInstruction("LDA", 0, 4*(nlv+nav+3), Rs, true));
		firstInstr = res.get(1);
		
		res.add(new LMAInstruction("COMP", 0, Rh, true));
		
		LMAInstruction jlInstr = new LMAInstruction("JLE", 0, -1, false);
		jlInstr.generateAddress();
		res.add(jlInstr);
		
		// Erreur
		LMAInstruction instr1 = new LMAInstruction("LDM", Rmessage, -1, false);
		instr1.generateAddress();
		instr1.setUnknownAddr(litErr);
		LMAInstruction instr2 = new LMAInstruction("LDM", Rentier, -1, false);
		instr2.generateAddress();
		instr2.setUnknownAddr(litSOF);
		res.add(instr1);
		res.add(instr2);
		res.add(new LMAInstruction("HALT", 0, 0, true));
		
		// On stocke F
		LMAInstruction instr3 = new LMAInstruction("STM", Rf, 4*(nlv+nav+1), Rs, false);
		instr3.generateAddress();
		jlInstr.setUnknownAddr(instr3);
		res.add(instr3);
		// On stocke R
		res.add(new LMAInstruction("STM", Rr, 4*(nlv+nav+2), Rs, true));
		// F = S
		res.add(new LMAInstruction("LDA", Rf, 0, Rs, true));
		// On augmente S
		res.add(new LMAInstruction("ADDA", Rs, 4*(nlv+nav+3), true));
		
		// On génère tous les Stmt de la méthode sauf
		// les Stmt contenus dans des blocs "false"
		//
		// On stoppe la génération dès qu'on tombe
		// soit sur un Stmt déjà généré ou soit sur
		// un objet méthode signifiant qu'on est à la fin
		Stmt tmp = l;
		while(!tmp.generated && !(tmp instanceof Method))
		{	
			res.addAll(tmp.translate());
			if(tmp instanceof CmdStmt)
				tmp = ((CmdStmt)tmp).next;
			else // tmp est un CondStmt
			{
				CondListStmt.add((CondStmt)tmp);
				tmp = ((CondStmt)tmp).ltrue;
			}
		}
		
		// Si le dernier tmp n'est pas un objet méthod
		// c'est qu'on est pas à la fin de la méthode.
		// Il faut donc ajouter un jump vers le label
		// déjà généré.
		if(!(tmp instanceof Method))
		{
			LMAInstruction jump = new LMAInstruction("JUMP", 0, -1, false);
			jump.setUnknownAddr(tmp.firstInstr);
			jump.generateAddress();
			res.add(jump);
		}
		
		// On prépare le retour de méthode
		returnInstr = new LMAInstruction("LDM", 0, 0, Rf, false);
		
		// Si le dernier tmp est un objet method
		// on ajoute un jump vers l'instruction 
		// de retour de la méthode
		if(tmp instanceof Method)
		{	
			LMAInstruction jump = new LMAInstruction("JUMP", 0, -1, false);
			jump.setUnknownAddr(returnInstr);
			jump.generateAddress();
			res.add(jump);
		}

		// On traduit ensuite les Stmt lFalse
		genLFalse(res, CondListStmt);
		
		// On ajoute les instructions de retour de la méthode
		returnInstr.generateAddress();
		res.add(returnInstr);
		res.add(new LMAInstruction("LDA", Rs, 0, Rf, true));
		res.add(new LMAInstruction("LDM", Rf, 4*(nlv+nav+1), Rs, true));
		res.add(new LMAInstruction("LDM", Rr, 4*(nlv+nav+2), Rs, true));
		res.add(new LMAInstruction("JUMP", 0, 0, Rr, true));

		res.add(new LMAInstruction("end of method " + m + "()"));
		
		// On définit l'adresse de la méthode dans la table d'indirection
		if(!isStatic)
		{
			IT.setAdress(m, level, firstInstr);
		}
		
		// Si la méthode est la main(), on définit le jump de début de programme
		if(m.equals("main"))
			JumpMainInstr.setUnknownAddr(firstInstr);

		return res;
	}
	
	public void genLFalse(ArrayList<LMAInstruction> res, ArrayList<CondStmt> CondListStmt)
	{
		int i = 0;
		Stmt tmp;
		Stmt firstTmp;
		ArrayList<CondStmt> newCondListStmt = new ArrayList<CondStmt>();
		
		while(i<CondListStmt.size())
		{
			tmp = CondListStmt.get(i).lfalse;
			firstTmp = tmp;
			
			while(!tmp.generated && !(tmp instanceof Method))
			{	
				res.addAll(tmp.translate());

				if(tmp instanceof CmdStmt)
					tmp = ((CmdStmt)tmp).next;
				else // tmp est un CondStmt
				{
					newCondListStmt.add((CondStmt)tmp);
					tmp = ((CondStmt)tmp).ltrue;	
				}
			}
			
			if(!(firstTmp instanceof Method))
			{
				CondListStmt.get(i).instrJGE.setArg2(firstTmp.firstInstr.getAddr());
			}else // On jump vers l'instruction de retour
			{
				CondListStmt.get(i).instrJGE.setArg2(returnInstr.getAddr());
			}
			
			// La fin du lFalse dirige vers un Stmt déjà généré, on jump
			// vers celui ci
			if(!(tmp instanceof Method))
			{
				LMAInstruction jump = new LMAInstruction("JUMP", 0, -1, false);
				jump.setUnknownAddr(tmp.firstInstr);
				jump.generateAddress();
				res.add(jump);
			}
			
			if(tmp instanceof Method)
			{	
				LMAInstruction jump = new LMAInstruction("JUMP", 0, -1, false);
				jump.setUnknownAddr(returnInstr);
				jump.generateAddress();
				res.add(jump);
			}

			i++;
		}
		
		if(!newCondListStmt.isEmpty())
			genLFalse(res, newCondListStmt);
		
	}

}

